<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive Whiteboard</title>
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Noto+Sans&display=swap"
  />
  <link
    href="https://fonts.googleapis.com/icon?family=Material+Icons"
    rel="stylesheet"
  />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=ink_eraser"
  />
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; }
    .toolbar {
      position:absolute; left:0; width:100%; height:8vh;
      display:flex; align-items:center; gap:10px;
      padding:0 10px; box-sizing:border-box;
      background:rgba(255,255,255,0.9); z-index:10;
    }
    #top-toolbar {
      top:0; justify-content:flex-start;
      font-family:'Noto Sans',sans-serif; font-size:1.2em;
      box-shadow:0 4px 6px rgba(0,0,0,0.3);
    }
    #bottom-toolbar {
      bottom:0; justify-content:flex-start;
      box-shadow:0 -4px 6px rgba(0,0,0,0.3);
    }
    .toolbar-button {
      width:32px; height:32px; border-radius:50%;
      background:white; box-shadow:0 2px 5px rgba(0,0,0,0.3);
      border:none; display:flex; justify-content:center; align-items:center;
      cursor:pointer;
    }
    .toolbar-button.locked { background:#ddd; }
    .material-icons, .material-symbols-outlined { font-size:20px; color:#000; }
    #board { position:absolute; left:0; right:0; touch-action:none; }
    .brush-slider {
      width:80px; -webkit-appearance:none; height:6px;
      background:#ddd; border-radius:3px; outline:none;
    }
    .brush-slider::-webkit-slider-thumb {
      -webkit-appearance:none; width:16px; height:16px; border-radius:50%;
      background:#777; cursor:pointer;
    }
    /* side panel */
    #boardListPanel {
      position: absolute;
      top: calc(6vh); /* Corrected to add 5px gap above */
      left: 0;
      width: 300px;
      background: white;
      box-shadow: 2px 0 6px rgba(0, 0, 0, 0.3);
      display: none;
      flex-direction: column;
      z-index: 20;
      overflow-y: auto;
    }
    .panel-button {
      margin:10px; padding:8px; border:none;
      background:white; box-shadow:0 2px 5px rgba(0,0,0,0.3);
      border-radius:4px; display:flex; align-items:center;
      gap:4px; cursor:pointer; font-family:'Noto Sans',sans-serif;
    }
    .board-item {
      display:flex; justify-content:space-between;
      align-items:center; padding:8px 12px; cursor:pointer;
      font-family:'Noto Sans',sans-serif;
    }
    .board-item:hover { background:#f0f0f0; }
    .board-item .trash {
      padding: 5px;
      border-radius: 4px;
      background: #f8d7da;
      color: #721c24;
      font-size: 1.2em;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: background 0.3s, transform 0.2s;
    }
    .board-item .trash:hover {
      background: #f5c6cb;
    }
    .board-item .trash:active {
      transform: scale(0.95);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
    .modal {
      position:fixed; top:0; left:0; width:100%; height:100%;
      background:rgba(0,0,0,0.3); display:none;
      align-items:center; justify-content:center; z-index:30;
    }
    .modal-content {
      background:white; padding:16px; border-radius:8px;
      box-shadow:0 2px 10px rgba(0,0,0,0.3);
      display:flex; flex-direction:column; gap:8px;
    }
    .modal-content label {
      display:flex; flex-direction:column; font-size:0.9em;
    }
    .modal-buttons {
      display:flex; justify-content:flex-end; gap:8px;
    }
    .modal-buttons button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      background: #007BFF;
      color: white;
      font-size: 1em;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: background 0.3s, transform 0.2s;
    }
    .modal-buttons button:hover {
      background: #0056b3;
    }
    .modal-buttons button:active {
      transform: scale(0.95);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    .modal-buttons button#cancelDelete {
      background: #6c757d;
    }
    .modal-buttons button#cancelDelete:hover {
      background: #5a6268;
    }
    select:disabled { background:#eee; }

    /* Password overlay */
    #passwordOverlay {
      position:fixed;
      z-index:1000;
      top:0;
      left:0;
      width:100vw;
      height:100vh;
      background:white;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #pinInput {
      font-size:1.5em;
      padding:10px 18px;
      border-radius:8px;
      border:1px solid #ccc;
      outline:none;
      text-align:center;
      letter-spacing:0.3em;
      width:140px;
    }
    #pinError {
      color:#c00;
      font-size:0.98em;
      margin-top:10px;
      display:none;
    }

    .toolbar-button.selected {
      background: #cce0ff !important;
      box-shadow: 0 2px 8px rgba(0,80,255,0.18);
      border: 2px solid #3399ff;
    }
    .toolbar-button.disabled, .toolbar-button:disabled {
      background: #f3f3f3 !important;
      color: #bbb !important;
      box-shadow: none !important;
      border: 1px solid #e0e0e0 !important;
      cursor: not-allowed !important;
      opacity: 0.7;
    }
    .toolbar-button.disabled span,
    .toolbar-button:disabled span {
      color: #bbb !important;
    }
  </style>
</head>
<body>
  <div id="passwordOverlay" style="position:fixed;z-index:1000;top:0;left:0;width:100vw;height:100vh;background:white;display:flex;align-items:center;justify-content:center;">
    <div style="background:#fff;padding:36px 32px 28px 32px;border-radius:18px;box-shadow:0 6px 32px rgba(0,0,0,0.18);display:flex;flex-direction:column;align-items:center;min-width:260px;">
      <div style="font-size:1.2em;margin-bottom:18px;">Enter PIN to access teacher whiteboard</div>
      <input id="pinInput" type="password" inputmode="numeric" maxlength="6" style="font-size:1.5em;padding:10px 18px;border-radius:8px;border:1px solid #ccc;outline:none;text-align:center;letter-spacing:0.3em;width:140px;" autofocus />
      <div id="pinError" style="color:#c00;font-size:0.98em;margin-top:10px;display:none;">Incorrect PIN</div>
    </div>
  </div>

  <div id="top-toolbar" class="toolbar">
    <button id="openBoardListBtn" class="toolbar-button">
      <span class="material-icons">view_list</span>
    </button>
    <button id="exportBtn" class="toolbar-button">
      <span class="material-icons">download</span>
    </button>
    <button id="uploadImageBtn" class="toolbar-button">
      <span class="material-icons">image</span>
    </button>
    <input type="file" id="imageInput" accept="image/*" style="display: none;">
    <span id="boardTitle">Loadingâ€¦</span>
  </div>

  <div id="boardListPanel" class="flex-col">
    <button id="addBoardBtn" class="panel-button">
      <span class="material-icons">add</span>
      <span>Add New</span>
    </button>
    <div id="boardsListContainer"></div>
  </div>

  <div id="bottom-toolbar" class="toolbar">

    <button id="undoBtn" class="toolbar-button">
  <span class="material-icons">undo</span>
</button>
<button id="redoBtn" class="toolbar-button">
  <span class="material-icons">redo</span>
</button>


  </div>
  <canvas id="board"></canvas>

  <div id="newItemModal" class="modal">
    <div class="modal-content">
      <label>
        Class Period:
        <select id="newPeriod">
          <option value="1">1st</option>
          <option value="2">2nd</option>
          <option value="3">3rd</option>
          <option value="4">4th</option>
          <option value="5">5th</option>
        </select>
      </label>
      <label>
        Override Name:
        <input type="text" id="overrideInput" placeholder="Custom name" />
      </label>
      <div class="modal-buttons">
        <button id="modalCancel">Cancel</button>
        <button id="modalOk">OK</button>
      </div>
    </div>
  </div>

  <div id="confirmDeleteModal" class="modal">
    <div class="modal-content">
      <p>Are you sure you want to delete this whiteboard?</p>
      <div class="modal-buttons">
        <button id="confirmDelete">Delete</button>
        <button id="cancelDelete">Cancel</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
    import {
      getDatabase, ref, onValue, onChildAdded, onChildRemoved,
      push, set, remove
    } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";

    // Firebase config
    const firebaseConfig = {
            apiKey: "AIzaSyBBxUdOHCB1fJI9mZgYHJ0HCg6p_8R_1-s",
            authDomain: "interactive-whiteboard-8bc1e.firebaseapp.com",
            projectId: "interactive-whiteboard-8bc1e",
            storageBucket: "interactive-whiteboard-8bc1e.firebasestorage.app",
            messagingSenderId: "403793324386",
            appId: "1:403793324386:web:c5f8da9579cd97f935a43b"
        };
    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);

    // DOM refs
    const topBar             = document.getElementById('top-toolbar');
    const openBoardListBtn   = document.getElementById('openBoardListBtn');
    const boardListPanel     = document.getElementById('boardListPanel');
    const boardsListContainer= document.getElementById('boardsListContainer');
    const addBoardBtn        = document.getElementById('addBoardBtn');
    const boardTitle         = document.getElementById('boardTitle');
    const modal              = document.getElementById('newItemModal');
    const newPeriod          = document.getElementById('newPeriod');
    const overrideIn         = document.getElementById('overrideInput');
    const modalOk            = document.getElementById('modalOk');
    const modalCancel        = document.getElementById('modalCancel');
    const canvas             = document.getElementById('board');
    const ctx                = canvas.getContext('2d');
    const exportBtn          = document.getElementById('exportBtn');
    const botBar             = document.getElementById('bottom-toolbar');
    const uploadImageBtn     = document.getElementById('uploadImageBtn');
    const imageInput         = document.getElementById('imageInput');

    // Helpers
    function ordinal(n) {
      const s=["th","st","nd","rd"], v=n%100;
      return n + (s[(v-20)%10]||s[v]||s[0]);
    }
    function isInside(wp) {
    return wp.x >= 0 && wp.x <= pageWidth
        && wp.y >= 0 && wp.y <= pageHeight;
    }

    function todayStr() {
      const d=new Date(), m=d.getMonth()+1,
            day=d.getDate(), y=d.getFullYear()%100;
      return `${m}/${day}/${y}`;
    }
    function makeBtn(icon, useSymbols=false){
      const btn = document.createElement('button');
      btn.className = 'toolbar-button';
      const cls = useSymbols?'material-symbols-outlined':'material-icons';
      btn.innerHTML = `<span class="${cls}">${icon}</span>`;
      return btn;
    }



    // State
    const pageWidth=2000, pageHeight=2000, minScale=0.2;
    let scale=1, translateX=0, translateY=0;
    let shapes=[], currentShape=null, ghostPath=[];
    let drawing=false, erasing=false, panning=false, locked=true;
    let currentTool='draw', currentColor='#000', brushSize=6;
    let panStart={}, startTranslate={};
    let pinch=false, initialDist=0, initialScale=1, pinchCenter={}, touching=false;
    let boardsMap={}, currentBoardId=null;
    let strokesRef, unsubAdd, unsubRemove;
    let backgroundImage = null;

    let rafId = null;
    let lastMoveUpdate = 0;
    let pendingMoveUpdates = new Set();

    // --- UNDO/REDO SYSTEM REWRITE START ---
    // (Moved below, after DOM elements are created)
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    let undoStack = [];
    let redoStack = [];
    let isUndoRedoInProgress = false;

    function updateUndoRedoButtons() {
      undoBtn.disabled = isUndoRedoInProgress || undoStack.length === 0;
      redoBtn.disabled = isUndoRedoInProgress || redoStack.length === 0;
    }

    function pushAction(action) {
      // When a new action is performed, push to undoStack and clear redoStack
      undoStack.push(action);
      redoStack = [];
      updateUndoRedoButtons();
    }

    // Helper: Add a stroke to Firebase, optionally with a specific ID
    function addStrokeToDB(stroke) {
      const strokeRef = stroke.id
        ? ref(db, `whiteboards/${currentBoardId}/strokes/${stroke.id}`)
        : push(ref(db, `whiteboards/${currentBoardId}/strokes`));
      const id = stroke.id || strokeRef.key;
      return set(strokeRef, {
        color: stroke.color,
        width: stroke.width,
        points: stroke.points
      }).then(() => id);
    }

    // Helper: Remove a stroke from Firebase by ID
    function removeStrokeFromDB(strokeId) {
      return remove(ref(db, `whiteboards/${currentBoardId}/strokes/${strokeId}`));
    }

    undoBtn.addEventListener('click', async () => {
      if (isUndoRedoInProgress || !undoStack.length) return;
      isUndoRedoInProgress = true;
      updateUndoRedoButtons();
      const action = undoStack.pop();
      try {
        if (action.type === 'add') {
          // Remove the stroke that was just added
          await removeStrokeFromDB(action.stroke.id);
        } else if (action.type === 'erase') {
          // Re-add all erased strokes (with original IDs)
          await Promise.all(action.strokes.map(s => addStrokeToDB(s)));
        }
        redoStack.push(action);
      } finally {
        isUndoRedoInProgress = false;
        updateUndoRedoButtons();
        render();
      }
    });

    redoBtn.addEventListener('click', async () => {
      if (isUndoRedoInProgress || !redoStack.length) return;
      isUndoRedoInProgress = true;
      updateUndoRedoButtons();
      const action = redoStack.pop();
      try {
        if (action.type === 'add') {
          // Re-add the stroke (with original ID)
          await addStrokeToDB(action.stroke);
        } else if (action.type === 'erase') {
          // Remove all erased strokes again
          await Promise.all(action.strokes.map(s => removeStrokeFromDB(s.id)));
        }
        undoStack.push(action);
      } finally {
        isUndoRedoInProgress = false;
        updateUndoRedoButtons();
        render();
      }
    });

    updateUndoRedoButtons();
    // --- UNDO/REDO SYSTEM REWRITE END ---

    // Build side panel
    function rebuildPanel(){
      boardsListContainer.innerHTML = '';
      for(const [id,data] of Object.entries(boardsMap)){
        const div=document.createElement('div');
        div.className='board-item';
        div.dataset.id=id;
        div.innerHTML=`
          <span>${data.name}</span>
          <span class="trash material-icons">delete</span>
        `;
        boardsListContainer.appendChild(div);
      }
    }

    // Side panel open/close
    openBoardListBtn.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent event bubbling
      console.log('Dropdown button clicked'); // Test log
      const isPanelVisible = boardListPanel.style.display === 'flex';
      boardListPanel.style.display = isPanelVisible ? 'none' : 'flex';
      if (!isPanelVisible) {
        boardListPanel.style.position = 'absolute';
        boardListPanel.style.top = `${topBar.offsetHeight + 5}px`; // Position below the top bar with a 5px gap
        boardListPanel.style.bottom = `${botBar.offsetHeight + 5}px`; // Add a 5px gap above the bottom bar
        boardListPanel.style.left = '0';
      }
    });

    document.addEventListener('click', (e) => {
      if (
        boardListPanel.style.display === 'flex' &&
        !boardListPanel.contains(e.target) &&
        e.target !== openBoardListBtn
      ) {
        boardListPanel.style.display = 'none';
      }
    });

    // Panel actions
    addBoardBtn.addEventListener('click', ()=>{
      overrideIn.value=''; newPeriod.disabled=false;
      modal.style.display='flex';
    });
    boardsListContainer.addEventListener('click', e => {
      const li = e.target.closest('.board-item');
      if (!li) return;
      const id = li.dataset.id;

      if (e.target.classList.contains('trash')) {
        // Open a confirmation dialog
        modal.style.display = 'flex';
        modal.querySelector('.modal-content').innerHTML = `
          <p>Are you sure you want to delete \"${boardsMap[id].name}\"?</p>
          <div class='modal-buttons'>
            <button id='confirmDelete'>Delete</button>
            <button id='cancelDelete'>Cancel</button>
          </div>
        `;

        // Add event listeners for the dialog buttons
        document.getElementById('confirmDelete').addEventListener('click', () => {
          remove(ref(db, `whiteboards/${id}`));
          if (id === currentBoardId) currentBoardId = null;
          modal.style.display = 'none';
        });

        document.getElementById('cancelDelete').addEventListener('click', () => {
          modal.style.display = 'none';
        });
      } else {
        loadBoard(id, boardsMap[id].name);
        boardListPanel.style.display = 'none';
      }
    });

    // Modal logic
    modalCancel.addEventListener('click', ()=> modal.style.display='none');
    overrideIn.addEventListener('input', ()=> {
      newPeriod.disabled=!!overrideIn.value.trim();
    });
    modalOk.addEventListener('click', ()=>{
      let name=overrideIn.value.trim();
      if(!name){
        const p=parseInt(newPeriod.value,10);
        name=`${ordinal(p)} - ${todayStr()}`;
      }
      const newRef=push(ref(db,'whiteboards'));
      set(newRef,{name}).then(()=>{
        modal.style.display='none';
        loadBoard(newRef.key,name);
      });
    });

    // Load boards list
    onValue(ref(db,'whiteboards'), snap=>{
      boardsMap=snap.val()||{};
      rebuildPanel();
      if(!currentBoardId||!boardsMap[currentBoardId]){
        const first=Object.keys(boardsMap)[0];
        first ? loadBoard(first,boardsMap[first].name)
              : boardTitle.textContent='No boards';
      }
    });

    // Load a board
    function loadBoard(id,name){
      if(unsubAdd) unsubAdd();
      if(unsubRemove) unsubRemove();
      currentBoardId=id;
      shapes=[]; render();
      boardTitle.textContent=name;
      rebuildPanel();
      strokesRef=ref(db,`whiteboards/${id}/strokes`);
      unsubAdd=onChildAdded(strokesRef,s=>{
        const st=s.val(); st.id=s.key;
        shapes.push(st); render();
      });
      unsubRemove=onChildRemoved(strokesRef,s=>{
        shapes=shapes.filter(x=>x.id!==s.key);
        render();
      });
    }

    // Bottom toolbar & tools
    exportBtn.addEventListener('click', ()=>{
      const xmlns="http://www.w3.org/2000/svg";
      const svg=document.createElementNS(xmlns,"svg");
      svg.setAttribute("width",pageWidth);
      svg.setAttribute("height",pageHeight);
      svg.setAttribute("viewBox",`0 0 ${pageWidth} ${pageHeight}`);
      for(const s of shapes){
        const p=document.createElementNS(xmlns,"path");
        const d=s.points.map((pt,i)=>
          i?`L${pt.x},${pt.y}`:`M${pt.x},${pt.y}`
        ).join("");
        p.setAttribute("d",d);
        p.setAttribute("stroke",s.color);
        p.setAttribute("stroke-width",s.width);
        p.setAttribute("fill","none");
        p.setAttribute("stroke-linecap","round");
        p.setAttribute("stroke-linejoin","round");
        svg.appendChild(p);
      }
      const str=new XMLSerializer().serializeToString(svg),
            blob=new Blob([str],{type:"image/svg+xml"}),
            url=URL.createObjectURL(blob),
            a=document.createElement("a");
      a.href=url; a.download="whiteboard.svg";
      document.body.appendChild(a); a.click();
      a.remove(); URL.revokeObjectURL(url);
    });

    const lockBtn=makeBtn('lock');
    botBar.appendChild(lockBtn);
    lockBtn.classList.add('locked');
    lockBtn.addEventListener('click', ()=>{
      locked=!locked;
      lockBtn.classList.toggle('locked',locked);
      lockBtn.innerHTML=`<span class="material-icons">${
        locked?'lock':'lock_open'
      }</span>`;
    });

    const resetBtn=makeBtn('center_focus_strong');
    botBar.appendChild(resetBtn);
    resetBtn.addEventListener('click', ()=>{
      const cx=canvas.width/2, cy=canvas.height/2;
      const wp=toWorld(cx,cy);
      scale=1; translateX=cx-wp.x; translateY=cy-wp.y; render();
    });

    const homeBtn=makeBtn('home');
    botBar.appendChild(homeBtn);
    homeBtn.addEventListener('click', ()=>{
      scale = 1;
      // Reset to original starting location: top-left of whiteboard at (0,0)
      translateX = 0;
      translateY = 0;
      render();
    });

    const brushSlider=document.createElement('input');
    brushSlider.type='range'; brushSlider.min=1; brushSlider.max=50;
    brushSlider.value=brushSize; brushSlider.className='brush-slider';
    botBar.appendChild(brushSlider);
    brushSlider.addEventListener('input', ()=>{
      brushSize=+brushSlider.value;
    });

    // --- LASSO/COPY/PASTE TOOL START ---
let lassoBtn, copyBtn, pasteBtn, trashBtn, pasteImageBtn;
let lassoing = false, lassoPath = [], lassoedStrokes = [], lassoBox = null;
let copiedStrokes = null, isMovingLasso = false, lassoMoveStart = null;
let lastPasteCursor = { x: 100, y: 100 };
let penBtns = [];
let pasteMode = false;
let pasteImageMode = false;
let images = [];
let overlayImages = [];

function pointInPolygon(pt, poly) {
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i].x, yi = poly[i].y;
    const xj = poly[j].x, yj = poly[j].y;
    const intersect = ((yi > pt.y) !== (yj > pt.y)) &&
      (pt.x < (xj - xi) * (pt.y - yi) / (yj - yi + 0.00001) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function getLassoedStrokes() {
  if (!lassoPath.length) return [];
  return shapes.filter(s => s.points.some(pt => pointInPolygon(pt, lassoPath)));
}

function getBoundingBox(strokes) {
  if (!strokes.length) return null;
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const s of strokes) {
    for (const pt of s.points) {
      minX = Math.min(minX, pt.x);
      minY = Math.min(minY, pt.y);
      maxX = Math.max(maxX, pt.x);
      maxY = Math.max(maxY, pt.y);
    }
  }
  return { minX, minY, maxX, maxY };
}

function updateLassoUI() {
  lassoedStrokes = getLassoedStrokes();
  lassoBox = getBoundingBox(lassoedStrokes);
  // Copy
  if (lassoedStrokes.length === 0) {
    copyBtn.disabled = true;
    copyBtn.classList.add('disabled');
    trashBtn.disabled = true;
    trashBtn.classList.add('disabled');
  } else {
    copyBtn.disabled = false;
    copyBtn.classList.remove('disabled');
    trashBtn.disabled = false;
    trashBtn.classList.remove('disabled');
  }
  // Paste
  if (!copiedStrokes) {
    pasteBtn.disabled = true;
    pasteBtn.classList.add('disabled');
    if (pasteMode) {
      pasteMode = false;
      if (currentTool === 'paste') currentTool = 'draw';
      updateToolSelection();
    }
  } else {
    pasteBtn.disabled = false;
    pasteBtn.classList.remove('disabled');
  }
}

function clearLasso() {
  lassoing = false;
  lassoPath = [];
  lassoedStrokes = [];
  lassoBox = null;
  isMovingLasso = false;
  lassoMoveStart = null;
  updateLassoUI();
  render();
}

function offsetStrokes(strokes, dx, dy) {
  return strokes.map(s => ({
    ...s,
    id: null, // new copy
    points: s.points.map(pt => ({ x: pt.x + dx, y: pt.y + dy }))
  }));
}

// Add buttons to toolbar
lassoBtn = makeBtn('gesture');
botBar.appendChild(lassoBtn);
lassoBtn.addEventListener('click', () => {
  currentTool = 'lasso';
  clearLasso();
  updateToolSelection();
});

copyBtn = makeBtn('content_copy');
botBar.appendChild(copyBtn);
copyBtn.disabled = true;
copyBtn.classList.add('disabled');
copyBtn.addEventListener('click', () => {
  if (lassoedStrokes.length) {
    copiedStrokes = lassoedStrokes.map(s => ({ ...s, points: s.points.map(pt => ({...pt})) }));
    pasteBtn.disabled = false;
    pasteBtn.classList.remove('disabled');
  }
});

pasteBtn = makeBtn('content_paste');
botBar.appendChild(pasteBtn);
pasteBtn.disabled = true;
pasteBtn.classList.add('disabled');
pasteBtn.addEventListener('click', () => {
  if (!copiedStrokes) return;
  currentTool = 'paste';
  pasteMode = true;
  updateToolSelection();
});

// --- Paste Image Tool ---
pasteImageBtn = makeBtn('image');
botBar.appendChild(pasteImageBtn);
pasteImageBtn.addEventListener('click', () => {
  currentTool = 'pasteImage';
  pasteImageMode = true;
  updateToolSelection();
});

// --- Paste Image by Clipboard URL ---
canvas.addEventListener('mousedown', async e => {
  if (currentTool === 'pasteImage' && pasteImageMode) {
    // Try to read clipboard text as URL
    let url = '';
    try {
      url = await navigator.clipboard.readText();
    } catch (err) {
      console.log('Clipboard access denied or not supported.');
      pasteImageMode = false;
      currentTool = 'draw';
      updateToolSelection();
      return;
    }
    // Basic check for image URL
    if (!url.match(/^https?:\/\/.+\.(gif|png|jpe?g|svg|webp)$/i)) {
      console.log('Clipboard does not contain a valid image URL:', url);
      pasteImageMode = false;
      currentTool = 'draw';
      updateToolSelection();
      return;
    }
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left, y = e.clientY - r.top;
    const wp = toWorld(x, y);
    // Dummy square size in world coords
    const dummySize = 120;
    overlayImages.push({
      x: wp.x,
      y: wp.y,
      size: dummySize,
      url: url
    });
    pasteImageMode = false;
    currentTool = 'draw';
    updateToolSelection();
    render();
    updateImageOverlays();
  }
});

function updateImageOverlays() {
  // Remove old overlays
  if (locked) return; // Don't update overlays when locked
  document.querySelectorAll('.canvas-image-overlay').forEach(el => el.remove());
  const canvasRect = canvas.getBoundingClientRect();
  for (const imgObj of overlayImages) {
    const imgDiv = document.createElement('div');
    imgDiv.className = 'canvas-image-overlay';
    imgDiv.style.position = 'absolute';
    imgDiv.style.pointerEvents = 'none';
    imgDiv.style.zIndex = 30;
    // Calculate screen position/size (scale with canvas, account for canvas offset)
    const cx = imgObj.x * scale + translateX;
    const cy = imgObj.y * scale + translateY;
    const size = imgObj.size * scale;
    imgDiv.style.left = (canvas.offsetLeft + cx - size/2) + 'px';
    imgDiv.style.top = (canvas.offsetTop + cy - size/2) + 'px'; // <-- fix below
    imgDiv.style.width = size + 'px';
    imgDiv.style.height = size + 'px';
    imgDiv.innerHTML = `<img src="${imgObj.url}" style="width:100%;height:100%;object-fit:contain;display:block;">`;
    document.body.appendChild(imgDiv);
  }
}

// Call updateImageOverlays on pan/zoom/resize
const origRender2 = render;
render = function() {
  origRender2();
  // Draw dummy squares for overlay images
  ctx.save();
  ctx.translate(translateX, translateY); ctx.scale(scale, scale);
  for (const imgObj of overlayImages) {
    ctx.save();
    ctx.strokeStyle = '#3399ff';
    ctx.lineWidth = 2/scale;
    ctx.setLineDash([8/scale, 6/scale]);
    ctx.strokeRect(imgObj.x - imgObj.size/2, imgObj.y - imgObj.size/2, imgObj.size, imgObj.size);
    ctx.restore();
  }
  ctx.restore();
  updateImageOverlays();
};
window.addEventListener('resize', updateImageOverlays);
// --- End Paste Image Tool ---

// Trash can tool
trashBtn = makeBtn('delete');
botBar.appendChild(trashBtn);
trashBtn.disabled = true;
trashBtn.classList.add('disabled');
trashBtn.addEventListener('click', async () => {
  if (!lassoedStrokes.length) return;
  // Remove all lassoed strokes from DB
  await Promise.all(lassoedStrokes.map(s => removeStrokeFromDB(s.id)));
  clearLasso();
  updateLassoUI();
});
// --- LASSO/COPY/PASTE TOOL END ---

    // Render function
    function render(){
      ctx.save();
      ctx.fillStyle='#fff';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      
      // Transform for pan/zoom
      ctx.translate(translateX,translateY);
      ctx.scale(scale,scale);
      
      // Draw grid dots
      const dotSpacing = 50;
      const dotRadius = 1;
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      for(let x = 0; x <= pageWidth; x += dotSpacing) {
        for(let y = 0; y <= pageHeight; y += dotSpacing) {
          ctx.beginPath();
          ctx.arc(x, y, dotRadius/scale, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw shapes
      for(const s of shapes){
        ctx.beginPath();
        ctx.strokeStyle=s.color;
        ctx.lineWidth=s.width;
        ctx.lineCap='round';
        ctx.lineJoin='round';
        const pts=s.points;
        if(pts.length){
          ctx.moveTo(pts[0].x,pts[0].y);
          for(let i=1; i<pts.length; i++)
            ctx.lineTo(pts[i].x,pts[i].y);
        }
        ctx.stroke();
      }
      
      // Draw current shape
      if(ghostPath.length){
        ctx.beginPath();
        ctx.strokeStyle=currentShape?currentShape.color:'#000';
        ctx.lineWidth=brushSize;
        ctx.lineCap='round';
        ctx.lineJoin='round';
        ctx.moveTo(ghostPath[0].x,ghostPath[0].y);
        for(let i=1; i<ghostPath.length; i++)
          ctx.lineTo(ghostPath[i].x,ghostPath[i].y);
        ctx.stroke();
      }
      
      ctx.restore();
    }

    // Pen/eraser/selection button feedback
    function updateToolSelection() {
      lassoBtn.classList.remove('selected');
      if (eraserBtn) eraserBtn.classList.remove('selected');
      pasteBtn.classList.remove('selected');
      pasteImageBtn.classList.remove('selected');
      penBtns.forEach(b => b.classList.remove('selected'));
      // Clear lasso selection if not in lasso tool
      if (currentTool !== 'lasso') {
        lassoing = false;
        lassoPath = [];
        lassoedStrokes = [];
        lassoBox = null;
        isMovingLasso = false;
        lassoMoveStart = null;
        render();
      }
      if (currentTool === 'lasso') {
        lassoBtn.classList.add('selected');
      } else if (currentTool === 'eraser') {
        if (eraserBtn) eraserBtn.classList.add('selected');
      } else if (currentTool === 'draw') {
        // Always highlight the penBtn with the current color (case-insensitive)
        penBtns.forEach(b => {
          if ((b.dataset.penColor || '').replace(/\s/g,'').toLowerCase() === (currentColor || '').replace(/\s/g,'').toLowerCase()) {
            b.classList.add('selected');
          }
        });
      } else if (currentTool === 'paste') {
        pasteBtn.classList.add('selected');
      } else if (currentTool === 'pasteImage') {
        pasteImageBtn.classList.add('selected');
      }
    }

    const eraserBtn=makeBtn('ink_eraser',true);
    botBar.appendChild(eraserBtn);
    eraserBtn.addEventListener('click', ()=> {
      currentTool='eraser';
      updateToolSelection();
    });

    // Pen color buttons
    const penColors = ['#000','#f00','#0f0','#00f','#ff0'];
    for(const c of penColors){
      const b=makeBtn('brush');
      b.querySelector('.material-icons').style.color=c;
      b.dataset.penColor = c.toLowerCase();
      botBar.appendChild(b);
      penBtns.push(b);
      b.addEventListener('click', ()=>{
        currentTool='draw'; currentColor=c;
        updateToolSelection();
        pasteMode = false;
      });
    }

    // On load, set tool selection
    updateToolSelection();
    updateLassoUI();

    // --- LASSO/COPY/PASTE INTEGRATION WITH EXISTING EVENTS ---
    canvas.addEventListener('mousedown',e=>{
      if (currentTool === 'lasso' && locked) {
        const r=canvas.getBoundingClientRect();
        const x = e.clientX-r.left, y = e.clientY-r.top;
        const wp = toWorld(x, y);
        lastPasteCursor = { x: wp.x, y: wp.y }; // Track for paste
        if (lassoBox && wp.x >= lassoBox.minX && wp.x <= lassoBox.maxX && wp.y >= lassoBox.minY && wp.y <= lassoBox.maxY) {
          isMovingLasso = true;
          lassoMoveStart = { x: wp.x, y: wp.y };
        } else {
          lassoing = true;
          lassoPath = [wp];
          lassoedStrokes = [];
          lassoBox = null;
          render();
        }
      } else if (currentTool === 'paste' && pasteMode && copiedStrokes) {
        const r=canvas.getBoundingClientRect();
        const x = e.clientX-r.left, y = e.clientY-r.top;
        const wp = toWorld(x, y);
        // Find bounding box of copiedStrokes
        const box = getBoundingBox(copiedStrokes);
        let dx = 0, dy = 0;
        if (box) {
          dx = wp.x - box.minX;
          dy = wp.y - box.minY;
        }
        const pasted = offsetStrokes(copiedStrokes, dx, dy);
        // Await all pastes and collect new IDs
        Promise.all(pasted.map(async s => {
          const newId = await addStrokeToDB(s);
          s.id = newId;
          return s;
        })).then(newStrokes => {
          lassoedStrokes = newStrokes;
          lassoBox = getBoundingBox(lassoedStrokes);
          // Switch to lasso tool and highlight the pasted strokes
          currentTool = 'lasso';
          pasteMode = false;
          updateToolSelection();
          updateLassoUI();
          render();
        });
      } else if (currentTool === 'pasteImage' && pasteImageMode) {
        // Try to read image from clipboard
        navigator.clipboard.read().then(async items => {
          for (const item of items) {
            for (const type of item.types) {
              if (type.startsWith('image/')) {
                const blob = await item.getType(type);
                const url = URL.createObjectURL(blob);
                const img = new window.Image();
                img.onload = function() {
                  const r = canvas.getBoundingClientRect();
                  const x = e.clientX - r.left, y = e.clientY - r.top;
                  const wp = toWorld(x, y);
                  // Calculate target height: half the visible canvas height in world coords
                  const visibleCanvasHeight = canvas.height;
                  const targetHeight = (visibleCanvasHeight / scale) / 2;
                  const aspect = img.width / img.height;
                  const targetWidth = targetHeight * aspect;
                  images.push({
                    x: wp.x,
                    y: wp.y,
                    width: targetWidth,
                    height: targetHeight,
                    img: img
                  });
                  render();
                  URL.revokeObjectURL(url);
                };
                img.src = url;
                // Only paste the first image found
                pasteImageMode = false;
                currentTool = 'draw';
                updateToolSelection();
                return;
              }
            }
          }
          alert('No image found in clipboard!');
        }).catch(() => {
          alert('Clipboard access denied or not supported.');
        });
      }
    });

    canvas.addEventListener('mousemove',e=>{
      if (currentTool === 'lasso' && locked) {
        const r=canvas.getBoundingClientRect();
        const x = e.clientX-r.left, y = e.clientY-r.top;
        const wp = toWorld(x, y);
        if (lassoing) {
          lassoPath.push(wp);
          updateLassoUI();
          render();        } else if (isMovingLasso && lassoedStrokes.length) {
          const dx = wp.x - lassoMoveStart.x;
          const dy = wp.y - lassoMoveStart.y;
          
          // Cancel any pending visual update frame
          if (rafId) cancelAnimationFrame(rafId);
          
          // Schedule visual update for smooth movement
          rafId = requestAnimationFrame(() => {
            // Update stroke positions visually
            for (const s of lassoedStrokes) {
              for (const pt of s.points) {
                pt.x += dx;
                pt.y += dy;
              }
              // Track for Firebase update
              pendingMoveUpdates.add(s);
            }
            
            lassoMoveStart = { x: wp.x, y: wp.y };
            lassoBox = getBoundingBox(lassoedStrokes);
            render();
            rafId = null;
            
            // Throttle Firebase updates using debounced batch update
            if (!window.fbUpdateTimeout) {
              window.fbUpdateTimeout = setTimeout(() => {
                if (pendingMoveUpdates.size > 0) {
                  // Create a single batch update
                  const updates = {};
                  for (const s of pendingMoveUpdates) {
                    updates[`whiteboards/${currentBoardId}/strokes/${s.id}`] = {
                      color: s.color,
                      width: s.width,
                      points: s.points
                    };
                  }
                  // Send batch update to Firebase
                  update(ref(db), updates).then(() => {
                    pendingMoveUpdates.clear();
                  });
                }
                window.fbUpdateTimeout = null;
              }, 100); // Increased delay to reduce updates
            }
          });
        }
      }
    });

    window.addEventListener('mouseup',e=>{
      if (currentTool === 'lasso' && locked) {
        if (lassoing) {
          lassoing = false;
          updateLassoUI();
          render();
        }
        if (isMovingLasso) {
          isMovingLasso = false;
          lassoMoveStart = null;
        }
      }
    });

    // Draw lasso and bounding box in render
    const origRender = render;
    render = function() {
      origRender();
      ctx.save();
      ctx.translate(translateX,translateY); ctx.scale(scale,scale);
      // Draw pasted images
      for (const imgObj of images) {
        ctx.drawImage(imgObj.img, imgObj.x, imgObj.y, imgObj.width, imgObj.height);
      }
      if (lassoing && lassoPath.length > 1) {
        ctx.save();
        ctx.strokeStyle = 'rgba(100,100,100,0.7)';
        ctx.lineWidth = 1.5/scale;
        ctx.setLineDash([8/scale, 6/scale]);
        ctx.beginPath();
        lassoPath.forEach((pt,i)=> i?ctx.lineTo(pt.x,pt.y):ctx.moveTo(pt.x,pt.y));
        ctx.stroke();
        ctx.restore();
      }
      if (lassoBox) {
        ctx.save();
        ctx.strokeStyle = 'grey';
        ctx.lineWidth = 2/scale;
        ctx.setLineDash([6/scale, 4/scale]);
        ctx.strokeRect(lassoBox.minX, lassoBox.minY, lassoBox.maxX-lassoBox.minX, lassoBox.maxY-lassoBox.minY);
        ctx.restore();
      }
      ctx.restore();
    };
    // --- END LASSO/COPY/PASTE INTEGRATION ---

    // Canvas sizing & drawing
    function resizeCanvas(){
      canvas.width=window.innerWidth;
      canvas.height=window.innerHeight;
      render();
    }
    window.addEventListener('resize', ()=>{ resizeCanvas(); render(); });
    resizeCanvas();

    function toWorld(x,y){
      return {
        x: (x-translateX)/scale,
        y: (y-translateY)/scale
      };
    }

    function distSeg(px,py,x1,y1,x2,y2){
      const dx=x2-x1, dy=y2-y1, d=Math.sqrt(dx*dx+dy*dy);
      if(d<0.01) return Math.sqrt((px-x1)*(px-x1)+(py-y1)*(py-y1));
      const t=((px-x1)*dx+(py-y1)*dy)/(d*d);
      if(t<0) return Math.sqrt((px-x1)*(px-x1)+(py-y1)*(py-y1));
      if(t>1) return Math.sqrt((px-x2)*(px-x2)+(py-y2)*(py-y2));
      return Math.abs((px-x1)*dy-(py-y1)*dx)/d;
    }

    function eraseSeg(x1,y1,x2,y2){
      const thr=brushSize/scale;
      const toRemove=[];
      const removedShapes=[];
      
      for(const s of shapes){
        const pts=s.points;
        for(let i=1; i<pts.length; i++){
          const d=distSeg(x1,y1,pts[i-1].x,pts[i-1].y,pts[i].x,pts[i].y);
          if(d<thr+s.width/2){
            toRemove.push(s.id);
            removedShapes.push({...s});
            break;
          }
        }
      }
      
      // Remove the strokes from Firebase
      Promise.all(toRemove.map(id => removeStrokeFromDB(id)));
      return removedShapes;
    }    // Drawing events
    canvas.addEventListener('mousedown', e => {
      const r = canvas.getBoundingClientRect();
      const x = e.clientX - r.left, y = e.clientY - r.top;
      const wp = toWorld(x, y);
      
      if(locked) {
        // Drawing mode
        if(currentTool === 'draw'){
          drawing = true;
          currentShape = {
            color: currentColor,
            width: brushSize,
            points: [wp]
          };
          ghostPath = [wp];
        } else if(currentTool === 'eraser'){
          erasing = true;
          const removed = eraseSeg(wp.x, wp.y, wp.x, wp.y);
          if(removed.length) {
            pushAction({
              type: 'erase',
              strokes: removed
            });
          }
        }
      } else {
        // Pan mode when unlocked - any mouse button starts panning
        panning = true;
        panStart = {x: e.clientX, y: e.clientY};
        startTranslate = {x: translateX, y: translateY};
        document.body.style.cursor = 'grabbing';
      }
      render();
    });

    canvas.addEventListener('mousemove', e => {
      const r = canvas.getBoundingClientRect();
      const x = e.clientX - r.left, y = e.clientY - r.top;
      const wp = toWorld(x, y);
      
      if(locked) {
        // Drawing mode
        if(drawing){
          if(isInside(wp)){
            ghostPath.push(wp);
            currentShape.points.push(wp);
          }
          render();
        } else if(erasing){
          const removed = eraseSeg(wp.x, wp.y, wp.x, wp.y);
          if(removed.length) {
            pushAction({
              type: 'erase',
              strokes: removed
            });
          }
          render();
        }
      }
      
      // Panning works in both locked and unlocked modes
      if(panning){
        translateX = startTranslate.x + (e.clientX - panStart.x);
        translateY = startTranslate.y + (e.clientY - panStart.y);
        render();
      }
    });

    window.addEventListener('mouseup', () => {
      if(locked && drawing){
        if(currentShape && currentShape.points.length > 1){
          // Add to Firebase
          addStrokeToDB(currentShape).then(id => {
            currentShape.id = id;
            pushAction({
              type: 'add',
              stroke: {...currentShape}
            });
          });
        }
        drawing = false;
        currentShape = null;
        ghostPath = [];
      }
      if(panning) {
        document.body.style.cursor = '';
      }
      erasing = false;
      panning = false;
      render();
    });


    // Password overlay logic
function getTodayPin() {
  const d = new Date();
  // e.g. 6/8/2025 -> 6825
  return `${d.getMonth()+1}${d.getDate()}${d.getFullYear()%100}`;
}
const overlay = document.getElementById('passwordOverlay');
const pinInput = document.getElementById('pinInput');
const pinError = document.getElementById('pinError');
pinInput.addEventListener('keydown', function(e) {
  if (e.key === 'Enter' || e.key === 'Done') {
    if (pinInput.value === getTodayPin()) {
      overlay.style.display = 'none';
      pinInput.value = '';
      pinError.style.display = 'none';
    } else {
      pinError.style.display = '';
      pinInput.value = '';
    }
  }
});
pinInput.addEventListener('input', function() {
  pinError.style.display = 'none';
});
pinInput.focus();


    // Zoom/Pan handlers
    canvas.addEventListener('wheel', e => {
      if(locked) return;  // Only zoom when unlocked
      e.preventDefault();
      
      const r = canvas.getBoundingClientRect();
      const x = e.clientX - r.left;
      const y = e.clientY - r.top;
      const wp = toWorld(x, y);
      
      const delta = -e.deltaY;
      const factor = Math.pow(1.001, delta);
      const newScale = Math.max(minScale, Math.min(5, scale * factor));
      if(newScale !== scale) {
        // Zoom centered on mouse position
        scale = newScale;
        translateX = x - wp.x * scale;
        translateY = y - wp.y * scale;
        render();
      }
    });

    // Middle mouse or space+left mouse to pan
    let spaceDown = false;
    window.addEventListener('keydown', e => {
      if(e.code === 'Space' && !spaceDown) {
        spaceDown = true;
        document.body.style.cursor = 'grab';
      }
    });
    window.addEventListener('keyup', e => {
      if(e.code === 'Space') {
        spaceDown = false;
        document.body.style.cursor = '';
      }
    });

    canvas.addEventListener('mousedown', e => {
      if(locked) return;  // Only allow interactions when unlocked
      
      const r = canvas.getBoundingClientRect();
      const x = e.clientX - r.left;
      const y = e.clientY - r.top;
      const wp = toWorld(x, y);
      
      if(e.button === 1 || (spaceDown && e.button === 0)) {
        e.preventDefault();
        panning = true;
        panStart = {x: e.clientX, y: e.clientY};
        startTranslate = {x: translateX, y: translateY};
        document.body.style.cursor = 'grabbing';
      } else if(!spaceDown) {
        // Regular drawing/erasing only when space isn't held
        if(currentTool === 'draw') {
          drawing = true;
          currentShape = {
            color: currentColor,
            width: brushSize,
            points: [wp]
          };
          ghostPath = [wp];
        } else if(currentTool === 'eraser') {
          erasing = true;
          const removed = eraseSeg(wp.x, wp.y, wp.x, wp.y);
          if(removed.length) {
            pushAction({
              type: 'erase',
              strokes: removed
            });
          }
        }
      }
      render();
    });

    canvas.addEventListener('mousemove', e => {
      const r = canvas.getBoundingClientRect();
      const x = e.clientX - r.left;
      const y = e.clientY - r.top;
      const wp = toWorld(x, y);
      
      if(panning && !locked) {  // Only pan when unlocked
        translateX = startTranslate.x + (e.clientX - panStart.x);
        translateY = startTranslate.y + (e.clientY - panStart.y);
        render();
      } else if(locked) {  // Drawing/erasing only when locked
        if(drawing) {
          if(isInside(wp)) {
            ghostPath.push(wp);
            currentShape.points.push(wp);
          }
          render();
        } else if(erasing) {
          const removed = eraseSeg(wp.x, wp.y, wp.x, wp.y);
          if(removed.length) {
            pushAction({
              type: 'erase',
              strokes: removed
            });
          }
          render();
        }
      }
    });

    window.addEventListener('mouseup', () => {
      if(panning) {
        panning = false;
        document.body.style.cursor = spaceDown ? 'grab' : '';
      }
      
      if(locked) {  // Drawing/erasing cleanup only when locked
        if(drawing) {
          if(currentShape && currentShape.points.length > 1) {
            addStrokeToDB(currentShape).then(id => {
              currentShape.id = id;
              pushAction({
                type: 'add',
                stroke: {...currentShape}
              });
            });
          }
          drawing = false;
          currentShape = null;
          ghostPath = [];
        }
        erasing = false;
      }
      render();
    });
  </script>
</body>
</html>
